parameters:
- name: bcVersion
  type: string
- name: alLanguageExtensionFileName
  type: string
  default: ''

- name: organizationName
  type: string
  default: ''
- name: appFolders
  type: object
  default:
  - MainApp
- name: testFolders
  type: object
  default: []
- name: masterBranch
  type: string
  default: WIP
- name: mainAppFolder
  type: string
  default: MainApp
- name: appReleaseVersionFormat
  type: string
  default: '{Manifest.Build}.{Manifest.Revision}'
- name: appVersionFormat
  type: string
  default: '{Container.Major}.{Manifest.Minor}.{Release.Major}.{Release.Minor}'
- name: customAppVersion
  type: string
  default: '0.0.0.0'
- name: manifestVersionMismatchAction
  type: string
  default: error
  values:
  - error
  - warning
  - none

- name: dockerMemory
  type: string
  default: 4g
- name: dockerIsolation
  type: string
  default: hyperv
  values:
  - hyperv
  - process

- name: publishOutput
  type: boolean
  default: true
- name: latestFolder
  type: string
  default: Latest
- name: beforeAppsInstallScript
  type: string
  default: ''
- name: latestDependencyAppPaths
  type: object
  default: []

- name: appSourceProductId
  type: string
  default: ''
- name: appSourceProductBcVersion
  type: string
  default: ''
- name: appSourceCredential
  type: string
  values:
  - none
  - softera
  default: none

stages:
- stage: Main
  displayName: Main
  jobs:
  - job: Main
    condition: or(startsWith(variables['Build.SourceBranchName'], variables['MasterBranch']), startsWith(variables['Build.SourceBranchName'], variables['merge']), startsWith(variables['Build.SourceVersionMessage'], 'Merge WIP to Release-'))
    variables:
    - name: OrganizationName
      value: ${{ parameters.organizationName }}

    - name: DockerMemory
      value: ${{ parameters.dockerMemory }}

    - name: IsPullRequest
      value: $[ ne(variables['System.PullRequest.PullRequestId'], '') ]
    - name: MasterBranch
      value: ${{ parameters.masterBranch }}
    - name: BcApplicationVersion
      value: ''
    steps:
    - checkout: self
      path: s/self
      clean: true
    - checkout: softeraDevTasks
      path: s/softeraDevTasks
      clean: true

    - task: DownloadSecureFile@1
      name: DownloadBCAppSigningCertificate
      inputs:
        secureFile: $(BCAppSigningCertificateSecureFileName)
      displayName: Download certificate for BC app signing

    - pwsh: |
        & $(
          $env:BUILD_SOURCESDIRECTORY |
          Join-Path -ChildPath 'softeraDevTasks' |
          Join-Path -ChildPath 'Scripts' |
          Join-Path -ChildPath 'CheckSystemResources.ps1'
        )
      condition: always()
      displayName: Checking computer resources

    - powershell: |
        $env:WorkspaceRoot = $(
          $env:BUILD_SOURCESDIRECTORY |
          Join-Path -ChildPath 'self'
        )
        Set-Location -LiteralPath $env:WorkspaceRoot

        & $(
          $env:BUILD_SOURCESDIRECTORY |
          Join-Path -ChildPath 'softeraDevTasks' |
          Join-Path -ChildPath 'Scripts' |
          Join-Path -ChildPath 'BuildApps.ps1'
        )
      env:
        BcVersion: ${{ parameters.bcVersion }}
        BcInsiderSasToken: $(BCSasToken)
        ALLanguageExtensionFileName: ${{ parameters.alLanguageExtensionFileName }}
        CodeSignCertPfxFile: $(DownloadBCAppSigningCertificate.SecureFilePath)
        CodeSignCertPfxPassword: $(BCAppSigningCertificatePassword)
        MainAppFolder: ${{ parameters.mainAppFolder }}
        AppFolders: ${{ convertToJson(parameters.appFolders) }}
        TestFolders: ${{ convertToJson(parameters.testFolders) }}
        AppReleaseVersionFormat: ${{ parameters.appReleaseVersionFormat }}
        AppVersionFormat: ${{ parameters.appVersionFormat }}
        CustomAppVersion: ${{ parameters.customAppVersion }}
        DockerMemory: $(DockerMemory)
        DockerIsolation: ${{ parameters.dockerIsolation }}
        BeforeAppsInstallScript: ${{ parameters.beforeAppsInstallScript }}
        LatestDependencyAppPaths: ${{ convertToJson(parameters.latestDependencyAppPaths) }}
      displayName: Run Pipeline
    # - ${{ if parameters.publishOutput }}:
    #   - powershell: |
    #       Set-StrictMode -Version Latest
    #       $ErrorActionPreference = 'Stop'

    #       $MainAppManifestPath = $env:MainAppFolder | Join-Path -ChildPath 'app.json'
    #       $MainAppManifestJson = Get-Content -LiteralPath $MainAppManifestPath -Raw
    #       $MainAppManifest = ConvertFrom-Json -InputObject $MainAppManifestJson
    #       [version]$ManifestVersionIs = $MainAppManifest.version


    #       $ManifestVersion = '{0}.{1}' -f $ManifestVersionIs.Build,$ManifestVersionIs.Revision
    #       Write-Host $ManifestVersion

    #       $BranchName = $(
    #         if ($env:IsPullRequest -eq 'false') {
    #             $env:Build_SourceBranchName
    #         } else {
    #             $env:System_PullRequest_TargetBranch -replace 'refs/heads/', ''
    #         }
    #       )

    #       if($env:Build_SourceBranchName.Contains('Release') -Or $env:Build_SourceBranch -match 'release')
    #       {
    #         $CommonPath = "C:\AzureDevOps\!Releases\$env:OrganizationName\$env:System_TeamProject\$env:Build_Repository_Name\$env:AppReleaseVersion\$BranchName-$env:BcApplicationVersion"
    #         $FileStoragePath = "\\filestorage\Projects\DevOps\$env:OrganizationName\$env:System_TeamProject\$env:Build_Repository_Name\$env:AppReleaseVersion\$BranchName-$env:BcApplicationVersion"
    #       }
    #       else
    #       {
    #         $CommonPath = "C:\AzureDevOps\!Prereleases\$env:OrganizationName\$env:System_TeamProject\$env:Build_Repository_Name\$env:AppReleaseVersion\$BranchName-$env:BcApplicationVersion"
    #         $FileStoragePath = "\\filestorage\Projects\DevOps\$env:OrganizationName\$env:System_TeamProject\$env:Build_Repository_Name\$env:AppReleaseVersion\$BranchName-$env:BcApplicationVersion"
    #       }

    #       $TempPath = "$CommonPath-Temporary-$env:Build_BuildID"
    #       if ([System.IO.Directory]::Exists($TempPath)) {
    #           throw "TempPath ($TempPath) already exist"
    #       }
    #       [System.IO.Directory]::CreateDirectory($TempPath)
    #       Copy-Item -Path * -Exclude .git -Destination $TempPath -Recurse -Force -ErrorAction SilentlyContinue
    #       $OldPath = "$CommonPath-Old"
    #       if ([System.IO.Directory]::Exists($OldPath)) {
    #           [System.IO.Directory]::Delete($OldPath, $true)
    #       }
    #       $Path = $CommonPath
    #       if ([System.IO.Directory]::Exists($Path)) {
    #           [System.IO.Directory]::CreateDirectory($Path)
    #           Copy-Item -Path $Path\* -Destination $OldPath -Recurse -Force -ErrorAction SilentlyContinue
    #           [System.IO.Directory]::Delete($Path, $true)
    #       }
    #       if (-not ([System.IO.Directory]::Exists($Path))) {
    #           Copy-Item -Path $TempPath -Destination $Path -Recurse -Force -ErrorAction SilentlyContinue
    #           [System.IO.Directory]::Delete($TempPath, $true)
    #       }


    #       $TempPaths = "$FileStoragePath-Temporary-$env:Build_BuildID"
    #       if ([System.IO.Directory]::Exists($TempPaths)) {
    #            [System.IO.Directory]::Delete($TempPaths, $true)
    #       }
    #       [System.IO.Directory]::CreateDirectory($TempPaths)
    #       Copy-Item -Path * -Exclude .git -Destination $TempPaths -Recurse -Force -ErrorAction SilentlyContinue
    #       $OldPaths = "$CommonPath-Old"
    #       if ([System.IO.Directory]::Exists($OldPaths)) {
    #           [System.IO.Directory]::Delete($OldPaths, $true)
    #       }
    #       $Paths = $FileStoragePath
    #       if ([System.IO.Directory]::Exists($Paths)) {
    #           [System.IO.Directory]::CreateDirectory($Paths)
    #           Copy-Item -Path $Paths\* -Destination $OldPath -Recurse -Force -ErrorAction SilentlyContinue
    #           [System.IO.Directory]::Delete($Paths, $true)
    #       }
    #       if (-not ([System.IO.Directory]::Exists($Paths))) {
    #           Copy-Item -Path $TempPaths -Destination $Paths -Recurse -Force -ErrorAction SilentlyContinue
    #           [System.IO.Directory]::Delete($TempPaths, $true)
    #       }


    #     env:
    #       MainAppFolder: ${{ parameters.mainAppFolder }}
    #     displayName: Copy files to BCApps
    # - ${{ if ne(parameters.latestFolder, '') }}:
    #   - powershell: |
    #       Set-StrictMode -Version Latest

    #       $NamePath = 'Latest-' + $env:Build_SourceBranchName.ToUpper()
    #       if($NamePath.Contains('RELEASE')){
    #       $NamePath = $NamePath -replace 'RELEASE-',''
    #       }

    #       $NameFile =  Get-Item -Path '.output/*' -Exclude .git -ErrorAction SilentlyContinue
    #       $outputFile = Split-Path $NameFile -leaf


    #       $Outputfilepath = @()
    #       if($env:Build_SourceBranchName.Contains('Release') -Or $env:Build_SourceBranch -match 'release')
    #       {
    #       $Path = "C:\AzureDevOps\!Releases\$env:OrganizationName\$env:System_TeamProject\$env:Build_Repository_Name\$env:LatestFolder"
    #       $FileStoragePath = "\\filestorage\Projects\DevOps\!Releases\$NamePath"
    #       foreach ($i in $outputFile)
    #       {
    #       $i = $i -replace ".{12}$"
    #       $Outputfilepath += "\\filestorage\Projects\DevOps\!Releases\$NamePath\$i"
    #       }
    #       }

    #       else{
    #       $Path = "C:\AzureDevOps\!Prereleases\$env:OrganizationName\$env:System_TeamProject\$env:Build_Repository_Name\$env:LatestFolder"
    #       $FileStoragePath = "\\filestorage\Projects\DevOps\!Prereleases\$NamePath"
    #       foreach ($i in $outputFile)
    #       {
    #       $i = $i -replace ".{12}$"
    #       $Outputfilepath += "\\filestorage\Projects\DevOps\!Prereleases\$NamePath\$i"
    #       }
    #       }

    #       if (-not ([System.IO.Directory]::Exists($FileStoragePath))) {
    #           [System.IO.Directory]::CreateDirectory($FileStoragePath)
    #       }

    #       foreach ($o2 in $Outputfilepath){
    #       if (Test-Path -Path "$o2*") {
    #       Write-Host "File Exists" -ForegroundColor red -BackgroundColor white
    #       (Get-ChildItem -Path "$o2*").Delete()
    #       }
    #       }

    #       if ([System.IO.Directory]::Exists($Path)) {
    #           [System.IO.Directory]::Delete($Path, $true)
    #       }
    #       if (-not ([System.IO.Directory]::Exists($Path))) {
    #           [System.IO.Directory]::CreateDirectory($Path)
    #           Copy-Item -Path * -Exclude .git -Destination $Path -Recurse -Force -ErrorAction SilentlyContinue
    #       }

    #       if ([System.IO.Directory]::Exists($FileStoragePath)) {
    #           Copy-Item -Path '.output/*' -Exclude .git -Destination $FileStoragePath -Recurse -Force -ErrorAction SilentlyContinue
    #       }


    #     env:
    #       LatestFolder: ${{ parameters.latestFolder }}
    #     displayName: Copy files to Latest folder
    # - ${{ if ne(parameters.appSourceProductBcVersion, '') }}:
    #   - pwsh: |
    #       Set-StrictMode -Version Latest
    #       $ErrorActionPreference = 'Stop'
    #       $InformationPreference = 'Continue'

    #       if (-not $env:APPSOURCE_PRODUCT_ID) {
    #         Write-Error -Message 'AppSource product ID was not specified.'
    #         return
    #       }

    #       Write-Information -MessageData "Ref: $env:BUILD_SOURCEBRANCH"

    #       $RefType, $RefName = $(
    #         if ($env:BUILD_SOURCEBRANCH -cmatch '^refs/(?<Type>\w+)s/(?<Name>.*)$') {
    #           $Matches['Type', 'Name']
    #         }
    #       )
    #       Write-Information -MessageData "Ref Type: $RefType"
    #       Write-Information -MessageData "Ref Name: $RefName"
    #       if ((-not $RefType) -and (-not $RefName)) {
    #         Write-Warning -Message 'Unrecognized source code version.'
    #         return
    #       }

    #       $BcVersion = $env:APPSOURCE_PRODUCT_BC_VERSION
    #       $RefSuitableForAppSourcePublishing = $(
    #         (($RefType -ceq 'head') -and ($RefName -ceq "code/$BcVersion")) -or
    #         (($RefType -ceq 'tag') -and ($RefName -clike "prerelease/*/$BcVersion"))
    #       )
    #       if (-not $RefSuitableForAppSourcePublishing) {
    #         Write-Information -Message 'Source code ref is not suitable for AppSource publishing.'
    #         return
    #       }

    #       $OutputAppsPath = '.output' | Join-Path -ChildPath '*.app'
    #       if (-not (Test-Path -Path $OutputAppsPath)) {
    #         Write-Warning -Message 'No apps to publish.'
    #         return
    #       }

    #       $FilestorageAppSourcePath = '\\filestorage\Projects\DevOps\!Pipeline\AppSource'
    #       $AppSourceProductPath = $(
    #         $FilestorageAppSourcePath |
    #         Join-Path -ChildPath 'Products' |
    #         Join-Path -ChildPath $env:APPSOURCE_PRODUCT_ID |
    #         Join-Path -ChildPath $BcVersion |
    #         Join-Path -ChildPath 'Prerelease'
    #       )
    #       Write-Information -MessageData "Initializing AppSource product folder '$AppSourceProductPath'..."
    #       New-Item -ItemType Directory -Path $AppSourceProductPath -Force | Out-Null

    #       $AppSourcePrereleaseManifestPath = $(
    #         $AppSourceProductPath |
    #         Join-Path -ChildPath 'manifest.json'
    #       )
    #       if (Test-Path -LiteralPath $AppSourcePrereleaseManifestPath) {
    #         Remove-Item -LiteralPath $AppSourcePrereleaseManifestPath
    #       }

    #       $AppSourceProductAppsPath = $(
    #         $AppSourceProductPath |
    #         Join-Path -ChildPath 'Apps'
    #       )
    #       New-Item -ItemType Directory -Path $AppSourceProductAppsPath -Force | Out-Null
    #       Remove-Item -Path ($AppSourceProductAppsPath | Join-Path -ChildPath '*')

    #       Write-Information -MessageData "Copying AppSource product apps to '$AppSourceProductAppsPath'..."
    #       Get-Item -Path $OutputAppsPath |
    #       Copy-Item -Destination $AppSourceProductAppsPath

    #       $MainAppManifestPath = $(
    #         $PWD.ProviderPath |
    #         Join-Path -ChildPath $env:MAIN_APP_FOLDER |
    #         Join-Path -ChildPath 'app.json'
    #       )
    #       $MainAppManifest = $(
    #         Get-Content -LiteralPath $MainAppManifestPath -Raw |
    #         ConvertFrom-Json
    #       )

    #       Write-Information -MessageData 'Reading apps...'
    #       $AppFiles = @(
    #         Get-ChildItem -LiteralPath $AppSourceProductAppsPath
    #       )
    #       foreach ($AppFile in $AppFiles) {
    #         [xml]$AppManifest = & 'C:\Program Files\7-Zip\7z.exe' e -so $AppFile.FullName 'NavxManifest.xml'
    #         $AppFile | Add-Member -MemberType NoteProperty -Name AppId -Value $AppManifest.Package.App.Id
    #         $AppFile | Add-Member -MemberType NoteProperty -Name AppName -Value $AppManifest.Package.App.Name
    #         $AppFile | Add-Member -MemberType NoteProperty -Name AppPublisher -Value $AppManifest.Package.App.Publisher
    #         $AppFile | Add-Member -MemberType NoteProperty -Name AppVersionText -Value $AppManifest.Package.App.Version
    #       }
    #       $AppFiles |
    #       Select-Object -Property AppId, AppName, AppPublisher, FullName |
    #       Format-Table -AutoSize |
    #       Out-String -Width 1000 |
    #       Write-Information

    #       $AppFolders = @(
    #         $env:APP_FOLDERS | ConvertFrom-Json
    #       )
    #       $AppIds = @(
    #         foreach ($AppFolder in $AppFolders) {
    #           $AppManifestPath = $(
    #             $PWD.ProviderPath |
    #             Join-Path -ChildPath $AppFolder |
    #             Join-Path -ChildPath 'app.json'
    #           )
    #           [psobject]$AppManifest = $(
    #             Get-Content -LiteralPath $AppManifestPath -Raw |
    #             ConvertFrom-Json
    #           )
    #           $AppManifest.id
    #         }
    #       )

    #       $MainAppFile = $AppFiles | Where-Object -Property AppId -EQ -Value $MainAppManifest.id
    #       $LibraryAppFiles = @(
    #         $AppFiles |
    #         Where-Object -Property AppId -NE -Value $MainAppManifest.id |
    #         Where-Object -Property AppId -In -Value $AppIds
    #       )
    #       Write-Information -MessageData 'Offer App:'
    #       Write-Information -MessageData $MainAppFile.FullName
    #       Write-Information -MessageData 'Library Apps:'
    #       $LibraryAppFiles | Select-Object -ExpandProperty FullName | Write-Information

    #       $AppSourcePrereleaseManifest = New-Object -TypeName psobject -Property $(
    #         [ordered]@{
    #           productId           = $env:APPSOURCE_PRODUCT_ID
    #           bcVersion           = $BcVersion
    #           productPath         = $AppSourceProductPath
    #           mainAppId           = $MainAppFile.AppId
    #           offerAppFilePath    = $MainAppFile.FullName
    #           libraryAppFilePaths = @($LibraryAppFiles.FullName)
    #           credential          = $env:APPSOURCE_CREDENTIAL
    #         }
    #       )

    #       Write-Information -MessageData "Writing AppSource prerelease manifest to '$AppSourcePrereleaseManifestPath'..."
    #       $AppSourcePrereleaseManifest |
    #       ConvertTo-Json |
    #       Out-File -LiteralPath $AppSourcePrereleaseManifestPath -Encoding utf8

    #       Write-Information -MessageData ''
    #       Write-Information -MessageData 'To publish app to AppSource run ''\\filestorage\Projects\DevOps\!Tools\Publish BC App to AppSource.bat''.'
    #     env:
    #       MAIN_APP_FOLDER: ${{ parameters.mainAppFolder }}
    #       APP_FOLDERS: ${{ convertToJson(parameters.appFolders) }}
    #       APPSOURCE_PRODUCT_ID: ${{ parameters.appSourceProductId }}
    #       APPSOURCE_PRODUCT_BC_VERSION: ${{ parameters.appSourceProductBcVersion }}
    #       APPSOURCE_CREDENTIAL: ${{ parameters.appSourceCredential }}
    #     displayName: Prepare AppSource product for publishing
    - pwsh: |
        Import-Module -Name BcContainerHelper -DisableNameChecking -Force
        Remove-BcContainer -containerName $env:ContainerName
        Flush-ContainerHelperCache -KeepDays 1
      condition: always()
      env:
        ContainerName: $(ContainerName)
      displayName: 'Cleanup'
