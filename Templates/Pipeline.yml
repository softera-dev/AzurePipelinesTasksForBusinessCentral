parameters:

# Required information:
  
- name: organizationName
  type: string

- name: bcVersion
  type: string


# Folders:

- name: appFolders
  type: object
  default:
  - MainApp

- name: testFolders
  type: object
  default: []

- name: mainAppFolder
  type: string
  default: MainApp

- name: latestDependencyAppPaths
  type: object
  default: []


# SCM information:

- name: masterBranch
  type: string
  default: WIP


# App versioning policy:

- name: appReleaseVersionFormat
  type: string
  default: '{Manifest.Build}.{Manifest.Revision}'

- name: appVersionFormat
  type: string
  default: '{Container.Major}.{Manifest.Minor}.{Release.Major}.{Release.Minor}'

- name: customAppVersion
  type: string
  default: '0.0.0.0'

- name: manifestVersionMismatchAction
  type: string
  default: error
  values:
  - error
  - warning
  - none


# Advanced build configuration:

- name: beforeAppsInstallScript
  type: string
  default: ''

- name: dockerMemory
  type: string
  default: 4g

- name: dockerIsolation
  type: string
  default: hyperv
  values:
  - hyperv
  - process

- name: alLanguageExtensionFileName
  type: string
  default: ''

- name: appSigningCertificatePath
  type: string
  default: \\filestorage\Projects\DevOps\!Pipeline\Certificates\Softera_Comodo_Code_Signing_Certificate_2020_11_09.pfx


stages:
- stage: Main
  displayName: Main
  jobs:
  - job: Main
    variables:
    - name: BcApplicationVersion
      value: ''
    - name: ContainerName
      value: ''
    - name: LatestFolder
      value: ''
    steps:
    - powershell: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $ExitCode = 0

        $FreeDiskSpace = Get-PSDrive -Name C | Select-Object -ExpandProperty Free
        if ($FreeDiskSpace -lt 10gb) {
            Write-Host -Object '##[error]There is no free disk space left. There must be atleast 10 GB.'
            $ExitCode = 1
        }

        Add-Type -AssemblyName 'Microsoft.VisualBasic'
        $ComputerInfo = [Microsoft.VisualBasic.Devices.ComputerInfo]::new()
        if ($ComputerInfo.AvailablePhysicalMemory -lt 4gb) {
            Write-Host -Object '##[error]There is no free memory space left. There must be atleast 4 GB.'
            $ExitCode = 1
        }

        exit($ExitCode)
      condition: always()
      displayName: Checking free disk and ram space

    - checkout: self
      path: self
      clean: true

    - checkout: softeraDevTasks
      clean: true

    - powershell: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $Ref = $(
          if ($env:SYSTEM_PULLREQUEST_PULLREQUESTID) {
            $env:BUILD_PULLREQUEST_TARGETBRANCH
          } else {
            $env:BUILD_SOURCEBRANCH
          }
        )
        Write-Host -Object "Target ref: $Ref"

        if ($Ref -notmatch '^refs/(?<RefType>heads|tags)/(?<RefName>.*)$') {
          throw "Unsupported ref '$Ref'."
        }
        $RefType, $RefName = $Matches['RefType', 'RefName']
        Write-Host -Object "  Type: $RefType"
        Write-Host -Object "  Name: $RefName"

        $Prerelease = $false
        $Release = $false
        $BranchBcVersion = 0
        switch ($RefType) {
          'heads': {
            if (($RefName -ne 'WIP') -and ($RefName -match '^(?<BranchName>code|releases)/bc(?<ExpectedBcArtifactMajorVersion>\d+)$')) {
              $Prerelease = $Matches['BranchName'] -eq 'code'
              $Release = $Matches['BranchName'] -eq 'releases'
              $ExpectedBcArtifactMajorVersion = [int]$Matches['ExpectedBcArtifactMajorVersion']
            }
            break
          }
          'tags': {
            if ($RefName -match '^release/(?<ReleaseVersion>\d+(?:\.\d+){0,3})/bc(?<ExpectedBcArtifactMajorVersion>\d+)$') {
              $Release = $true
              $ExpectedBcArtifactMajorVersion = [int]$Matches['ExpectedBcArtifactMajorVersion']
            }
            break
          }
        }
        Write-Host -Object "  Prerelease: $Prerelease"
        Write-Host -Object "  Release: $Prerelease"
        if ($ExpectedBcArtifactMajorVersion) {
          Write-Host -Object "  Expected Container Major Version: $ExpectedBcArtifactMajorVersion"
        }

        [string[]]$Global:AppFolders = $env:AppFolders | ConvertFrom-Json
        [string[]]$Global:TestFolders = $env:TestFolders | ConvertFrom-Json
        Write-Host
        Write-Host -Object "App folders: $(ConvertTo-Json -InputObject $AppFolders)"
        Write-Host -Object "Test app folders: $(ConvertTo-Json -InputObject $TestFolders)"

        Write-Host
        Write-Host -Object "BC version given $env:BcVersion"
        $Pattern = '^(?<Type>OnPrem|Sandbox)\/(?<Version>Current|NextMinor|NextMajor|\d+(?:\.\d+){0,3})\/(?<Country>base|w1|[a-zA-Z]{2})$'
        if ($env:BcVersion -notmatch $Pattern) {
          Write-Host -Object 'BC version expected pattern ''<OnPrem|Sandbox>/<Current|NextMinor|NextMajor|Numeric version, eg 20.0>/<base or w1 or country>'' (case sensitive)'
          throw 'BC version doesn''t match pattern. '
        }

        Write-Host
        Write-Host -Object "Parsed artifact type:    $($Matches.Type)"
        Write-Host -Object "Parsed artifact version: $($Matches.Version)"
        Write-Host -Object "Parsed artifact country: $($Matches.Country)"
        $GetBcArtifactUrlParameters = @{
          Type           = $Matches.Type
          Select         = 'Latest'
          Version        = $Matches.Version -replace 'Current|NextMinor|NextMajor', ''
          Country        = $Matches.Country
        }
        switch ($Matches.Version) {
          'Current' {
            $GetBcArtifactUrlParameters.Select = 'Current'
            break
          }
          { $_ -in @('NextMinor', 'NextMajor') } {
            $GetBcArtifactUrlParameters.SasToken = $env:BcInsiderSasToken
            $GetBcArtifactUrlParameters.Select = $Matches.Version
            break
          }
        }
        Write-Host -Object "Get-BCArtifactUrl parameters: $(ConvertTo-Json -InputObject $GetBcArtifactUrlParameters -Depth 1)"

        $BcArtifactUrl = Get-BCArtifactUrl @GetBcArtifactUrlParameters
        Write-Host -Object "BC artifact URL: $BcArtifactUrl"
        
        $ApplicationArtifactPath = Download-Artifacts -artifactUrl $BcArtifactUrl
        
        $BcArtifactManifest = Get-Content -LiteralPath ($ApplicationArtifactPath | Join-Path -ChildPath 'manifest.json') | ConvertFrom-Json
        [version]$Global:ArtifactVersion = $BcArtifactManifest.version
        [version]$Global:PlatformVersion = $BcArtifactManifest.platform

        if ($ExpectedBcArtifactMajorVersion) {
          if ($ArtifactVersion.Major -ne $ExpectedBcArtifactMajorVersion)) {
            throw "BC version in ref name ($ExpectedBcArtifactMajorVersion) does not match received BC artifact ($ArtifactVersion.Major)."
          }
          if ($ArtifactVersion.Minor -ne 0) {
            throw "Use only RTM versions (minor version = 0) to ensure that app functionality works on all BC CUs."
          }
        }

        Write-Host

        $Global:BaseFolder = "$env:BUILD_SOURCESDIRECTORY\self"
        Write-Host -Object "Base folder: '$BaseFolder'"

        $Global:DependenciesFolder = "\\filestorage\Projects\DevOps\!Prereleases\BC$($ArtifactVersion.Major)"
        Write-Host -Object "Dependencies folder: '$DependenciesFolder'"

        $LatestFolder = ''
        switch ($true) {
          $Prerelease {
            $LatestFolder = "\\filestorage\Projects\DevOps\!Prereleases\BC$($ArtifactVersion.Major)"
            break
          }
          $Release {
            $LatestFolder = "\\filestorage\Projects\DevOps\!Releases\BC$($ArtifactVersion.Major)"
            break
          }
        }
        Write-Host -Object "Latest folder: '$LatestFolder'"


        $FilestorageCredential = Import-Clixml -Path '\\filestorage\Projects\DevOps\!Pipeline\Credentials\SOFTERA.Azure_Pipelines.clixml'
        $FilestorageCredential | Add-Member -MemberType NoteProperty -Name UnsafePassword -Value $FilestorageCredential.GetNetworkCredential().Password

        
        $NewBCContainer = {
          param(
            [hashtable]$Parameters
          )

          $Parameters['isolation'] = $env:DockerIsolation

          New-BcContainer @Parameters

          Write-Host -Object "Running script inside container: $env:BeforeAppsInstallScript"
          if ($env:BeforeAppsInstallScript) {
            Invoke-ScriptInBcContainer -containerName $Parameters.containerName -argumentList $env:BeforeAppsInstallScript -scriptBlock {
              param(
                [string]$BeforeAppsInstallScript
              )

              Invoke-Expression -Command $BeforeAppsInstallScript
            }
          }

          if (-not $env:ALLanguageExtensionFileName) {
            Invoke-ScriptInBcContainer $Parameters.containerName -scriptblock {
              $ProgressPreference = 'SilentlyContinue'
              Remove-Item -Path 'C:\run\*.vsix'
            }
          }

          if (-not [string]::IsNullOrEmpty($env:ALLanguageExtensionFileName)) {
            Copy-FileToBCContainer -containerName $Parameters.containerName -localPath $env:ALLanguageExtensionFileName -containerPath 'C:\run\ALLanguage.vsix'
          }

          [version]$AppVersion = $(
            Get-Content -Path "$BaseFolder\$env:MainAppFolder\app.json" |
            ConvertFrom-Json |
            Select-Object -ExpandProperty application
          )
          foreach ($AppFolder in $AppFolders) {
            Write-Host
            Write-Host -Object "Updating app version in '$AppFolder'..."

            [version]$CustomAppVersion = $env:CustomAppVersion

            $AppManifestPath = "$BaseFolder\$AppFolder\app.json"
            $AppManifest = Get-Content -Path $AppManifestPath | ConvertFrom-Json
            [version]$ManifestVersion = $AppManifest.version
  
            $VersionNumberPattern = '\{(?<Identifier>[a-zA-Z.]+)\}'
            [System.Text.RegularExpressions.MatchEvaluator]$VersionNumberEvaluator = {
              param(
                [System.Text.RegularExpressions.Match]$Match
              )

              switch -CaseSensitive ($Match.Groups['Identifier'].Value) {
                'Manifest.Major' { $ManifestVersion.Major }
                'Manifest.Minor' { $ManifestVersion.Minor }
                'Manifest.Build' { $ManifestVersion.Build }
                'Manifest.Revision' { $ManifestVersion.Revision }
                'Container.Major' { $BcArtifactVersion.Major }
                'Container.Minor' { $BcArtifactVersion.Minor }
                'Container.Build' { $BcArtifactVersion.Build }
                'Container.Revision' { $BcArtifactVersion.Revision }
                'Custom.Major' { $CustomAppVersion.Major }
                'Custom.Minor' { $CustomAppVersion.Minor }
                'Custom.Build' { $CustomAppVersion.Build }
                'Custom.Revision' { $CustomAppVersion.Revision }
                'Release.Major' { $SelectedAppReleaseVersion.Major }
                'Release.Minor' { $SelectedAppReleaseVersion.Minor }
                'Release.Build' { $SelectedAppReleaseVersion.Build }
                'Release.Revision' { $SelectedAppReleaseVersion.Revision }
              }
            }

            [version]$SelectedAppReleaseVersion = [regex]::Replace($env:AppReleaseVersionFormat, $VersionNumberPattern, $VersionNumberEvaluator)
            [version]$SelectedAppVersion = [regex]::Replace($env:AppVersionFormat, $VersionNumberPattern, $VersionNumberEvaluator)
            if ($ManifestVersion.Major -ne $SelectedAppVersion.Major -or `
                $ManifestVersion.Minor -notin @(0, $SelectedAppVersion.Minor) -or `
                $ManifestVersion.Build -ne $SelectedAppVersion.Build -and `
                $ManifestVersion.Revision -ne $SelectedAppVersion.Revision) {
              if ($ManifestVersionMismatchAction -in @('warning', 'error')) {
                Write-Warning -Message "Manifest app version does not match selected app version."
              }
              if ($ManifestVersionMismatchAction -eq 'error') {
                exit(1)
              }
            }
            Write-Host -Object "Selected application release version: $SelectedAppReleaseVersion"
            Write-Host -Object "Selected application version: $SelectedAppVersion"

            $AppManifest.version = [string]$SelectedAppVersion
            ConvertTo-Json -InputObject $AppManifest | Set-Content -LiteralPath $AppManifestPath
          }


          Write-Host
          Write-Host -Object 'Reading potential dependencies...'
          $PotencialDependencies = $(
            Invoke-ScriptInBcContainer -containerName $Parameters.containerName -argumentList $Global:FilestorageCredential.UserName, $Global:FilestorageCredential.UnsafePassword, $Global:DependenciesFolder -scriptblock {
              params(
                [string]$FilestorageUserName,
                [string]$FilestoragePassword,
                [string]$DependenciesFolder
              )

              Set-StrictMode -Version Latest
              $ErrorActionPreference = 'Stop'

              # Containers do not have access to filestorage by default. Login does not persist between Invoke-ScriptInBcContainer invocations even with /persistent!
              net use '\\filestorage.softera.lt' /USER:$FilestorageUserName $FilestoragePassword

              Get-ChildItem -LiteralPath $DependenciesFolder -Filter '*.app' -Recurse |
              ForEach-Object -Process {
                Get-NAVAppInfo -Path $_.FullName |
                Add-Member -MemberType NoteProperty -Name FilePath -Value $_.FullName -PassThru
              }
            }
          }
        }
        Write-Host -Object "Potential dependencies: $(ConvertTo-Json -InputObject $PotencialDependencies)"

        Write-Host
        Write-Host -Object 'Sorting app folders...'
        $UnknownAppDependencies = @()
        $SortedAppFolders = Sort-AppFoldersByDependencies -baseFolder $Global:BaseFolder -appFolders @($Global:AppFolders; $Global:TestFolders) -unknownDependencies ([ref]$UnknownAppDependencies)
        
        Write-Host
        Write-Host -Object 'Sorting app folders...'
        $UnknownAppDependencies = @()
        $SortedAppFolders = Sort-AppFoldersByDependencies -baseFolder $Global:BaseFolder -appFolders @($Global:AppFolders; $Global:TestFolders) -unknownDependencies ([ref]$UnknownAppDependencies)
        

        $LicensePath = "\\filestorage\Projects\DevOps\!Pipeline\Licenses\BC$($PlatformVersion.Major)_.flf"
        Resolve-Path -LiteralPath $LicensePath | Out-Null
        Write-Host -Object "Selected license path for platform BC$($PlatformVersion.Major): $LicensePath"

        $ContainerName = -join [char[]]([char]'a'..[char]'z' | Get-Random -Count 8)
        Write-Host -Object "##vso[task.setvariable variable=ContainerName;]$ContainerName"

        $GetRunAlPipelineParameters = @{
          pipelinename                = 'Build'
          containerName               = $ContainerName
          artifact                    = $BcArtifactUrl
          baseFolder                  = $BaseFolder
          appFolders                  = $AppFolders
          testFolders                 = $TestFolders
          licenseFile                 = $LicensePath
          memoryLimit                 = $env:DockerMemory
          codeSignCertPfxFile         = $CodeSignCertPfxFile
          codeSignCertPfxPassword     = Get-Content -LiteralPath "$CodeSignCertPfxFile.password" | ConvertTo-SecureString
          installApps                 = @()
          installTestRunner           = $true
          installTestFramework        = $true
          installTestLibraries        = $true
          azureDevOps                 = $true
          NewBCContainer              = $NewBCContainer
        }
        Run-AlPipeline @GetRunAlPipelineParameters


        if ($LatestFolder) {
          Write-Host
          Write-Host -Object "Copying built apps to '$LatestFolder'..."
          New-Item -ItemType Directory -Path $LatestFolder -Force
          Copy-Item -Path "$BaseFolder\.output\*.app" -Destination $LatestFolder -Force
        }
      env:
        BcVersion: ${{ parameters.bcVersion }}
        BcInsiderSasToken: $(BCSasToken)
        ALLanguageExtensionFileName: ${{ parameters.alLanguageExtensionFileName }}
        CodeSignCertPfxFile: ${{ parameters.appSigningCertificatePath }}
        MainAppFolder: ${{ parameters.mainAppFolder }}
        AppFolders: ${{ convertToJson(parameters.appFolders) }}
        TestFolders: ${{ convertToJson(parameters.testFolders) }}
        AppReleaseVersionFormat: ${{ parameters.appReleaseVersionFormat }}
        AppVersionFormat: ${{ parameters.appVersionFormat }}
        CustomAppVersion: ${{ parameters.customAppVersion }}
        BeforeAppsInstallScript: ${{ parameters.beforeAppsInstallScript }}
        LatestDependencyAppPaths: ${{ convertToJson(parameters.latestDependencyAppPaths) }}
        DockerMemory: ${{ parameters.dockerMemory }}
        DockerIsolation: ${{ parameters.dockerIsolation }}
      displayName: Run Pipeline
  
    - powershell: |
        Remove-BcContainer -containerName $env:ContainerName
        Flush-ContainerHelperCache -KeepDays 1
      condition: always()
      env:
        ContainerName: $(ContainerName)
      displayName: Ensure container is removed.